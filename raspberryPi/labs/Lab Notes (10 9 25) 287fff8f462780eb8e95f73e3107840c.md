# Lab Notes (10.9.25)

# Lab: **Wireless Ambient Light Sensors**

**General Description:**

Configure your system to wirelessly send ambient light sensor data from the ESP32 to the Raspberry Pi via TCP or UDP message over Wi-Fi.Â  Configure your Pi to visualize or sonify the data in some 1:1 way (terminal output or printing values ðŸ”¥**DOES NOT COUNT**ðŸ”¥)

If you use UDP, when the message arrives at the Pi as a UDP packet you *may* need to process it with some language - possibly repackaging it as an OSC message. 

This is a **low-latency application**.

## **Possible Configurations:**

```

1.

HW: photoresistor   ->   ESP32   ->   WiFi   ->   Python   ->   SC3/Processing
SF:                      TCP/UDP ->               socket
                                                  OSC      ->   OSCdef/oscP5
2.

HW: photoresistor   ->   ESP32   ->   WiFi   ->   Processing
SF:                      TCP/UDP ->               UDP/Client
                                                                  
3.

HW: piezo           ->   ESP32   ->   WiFi   ->   SC3/Processing
SF:                      OSC     ->               OSCdef/oscP5 
```

Set up ESP32 as wifi STATION.

```python
#include <WiFi.h>

const char* ssid = "yale wireless";
const char* password = "";

void setup(){
    Serial.begin(115200);
    delay(1000);

    WiFi.mode(WIFI_STA); //Optional
    WiFi.begin(ssid, password);
    Serial.println("\nConnecting");

    while(WiFi.status() != WL_CONNECTED){
        Serial.print(".");
        delay(100);
    }

    Serial.println("\nConnected to the WiFi network");
    Serial.print("Local ESP32 IP: ");
    Serial.println(WiFi.localIP());
}

void loop(){}
```

^code for setting up wifi

## Required components:

1. IP address of ESP32 and Pi (or laptop)
2. Expected Ports for Processing/SuperCollider/Whatever
3. You will have to use Yale Wireless (not YaleSecure) for communication
    1. For both ESP32 and your laptop or Pi (not sure this is a requirementâ€¦)
    2. Or an ad hoc network using your laptop (not recommended)

## Regarding the photoresistor

**Wiring**: the photoresistor should be wired with a resistor going to ground from the side that returns to the ADC sensor pin.

Remember that the photo "sensor" is itself a resistor. So, to "sense" a difference in voltage across it you must have a complete circuit, voltage (preferably 3.3v) to GND with the sensor in between. 

![image.png](Lab%20Notes%20(10%209%2025)%20287fff8f462780eb8e95f73e3107840c/image.png)

![image.png](Lab%20Notes%20(10%209%2025)%20287fff8f462780eb8e95f73e3107840c/image%201.png)

Need to connect to ADC input to receive analog input.

Canâ€™t use ADC2 if wifi is on, can only use ADC1

However, this particular board Iâ€™m using has power and ADC1 on opposite sides, but i canâ€™t access both sides of the ESP32 at once. Therefore, Iâ€™m stuck at the wiring stageâ€¦

## Regarding the piezo (touch sensor) [NOT PART OF LAB]

**Wiring**: the piezo should be wired with a resistor between ground and the ADC sensor pin. **Do not attach +3 or +5 volts to the piezo**.

## Links:

[https://processing.org/reference/libraries/net/index.html](https://processing.org/reference/libraries/net/index.html)

## **Advanced Configuration:**

Test with both TCP and UDP and note the difference in performance.

## **Print your ESP32 MAC Address (not necessary F24)**

```arduino
#include "WiFi.h"

void setup(){

Serial.begin(115200);

WiFi.mode(WIFI_MODE_STA);

}

void loop(){

Serial.println(WiFi.macAddress());

delay(500);

}
```

# **Technical Notes:**

1. Never trust code you find on the internet. Okay, use it, but if it comes with no explanation or bona fides, proceed at your own peril. At the very minimum, you will end up having to do some digging into classes with which you are unfamiliar.
2. Never trust libraries you find in the Arduino Library Manager. OSC is *partially functional, ArduinoOSC is non-functional re: wireless (as of 2019). There is a functional third party library tested as working as of 10.12.24. That library is here: [https://github.com/CNMAT/OSC](https://github.com/CNMAT/OSC)
3. Python 'address' errors relating to 'socket' or 'python-osc' libraries are mostly likely caused by 1) a problem with the network (no connectivity) or a problem with your config (wrong IP, etc). However, I have seen this problem when one application (SuperCollider) had an OSCFunc listening to a port for OSC messages. Python could not listen on that port until SC3 was closed.
    1. **You can never have multiple serial clients listening to the same communication.**
4. When using a library, it is fine to first guess at how the functions work, but you will need to fall back to the documentation. For example, the Arduino UDP library has both a â€˜printfâ€™ and a â€˜printâ€™ function that take different parameters.
5. ESP32 gotcha: using Wifi makes certain ADC pins unusable.

# Upload your work

â€¦to your Lab 6 folder in your git repo

# Following Class (or maybe duringâ€¦)

â€¦functional code will be uploaded to the Files associated with this lecture note.